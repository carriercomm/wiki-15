This is not about Benjamin Pierce's book ''Types and programming languages'' but it is on the same topic.

Reading some more of JonUdell""s blog(s) I realized/remembered that there is this strange conversation going on that pits "dynamic" languages (such as Perl, Python, Ruby & Smalltalk) against "static" ones (C, C++, Java), where dynamic and static are generally used, I think, to qualify the language's type system.

What is interesting to me about this "debate" is that while the "dynamic" languages are held up as exemplars of "agile programming" tools, their inherent weaknesses - mostly the overhead of late binding in the runtime system - are recognized. The static languages are recognized as allowing the possibility of higher performance (because types are known at compile time), but are seen as clumsy, unwieldy, and prolix. (Both the edit-compile-run-crash loop and always having to declare the type of something are seen as drags on the progammer, which they are.)

What astonishes me is there seems to be no knowledge, or mention, of an existing synthesis of this dichotomy: namely, ''static polymorphic typing with type inference'' - the so-called [[http://c2.com/cgi/wiki?HindleyMilnerTypeInference ''Hindley-Milner'']] type system, which first debuted in ML.

Adherents to dynamic languages are unwilling to give up this dynamism, and are willing to pay a sometimes hefty price in performance, because they mistake "dynamic typing" with "agility", when truly much of the power and usefulness of these languages inheres in their interactivity, rather than in their type system.

I would like to suggest that [[http://haskell.org Haskell]] and [[http://www.ocaml.org Objective Caml]] (OCaml) be considered "agile" languages. They have all the requisite qualities:

* flexible type systems with type inference (less burden on the programmer);

* both interactive "top levels" and compilers (yielding both interactive development and high-performance);

* powerful libraries (this is truer of OCaml than Haskell, but this is changing).

In addition, their static typing confers two powerful advantages:

* many errors can be caught at compile time that in dynamic languages manifest only at run time, if at all;

* the compiler and runtime system can be made much more efficient - no late-binding lookups are necessary, and no runtime type information needs to be carried around.

And I haven't even mentioned the most compelling (for me) aspect of both languages: their functional programming roots. Both are fully-fledged functional languages, with higher-order (first class) functions, algebraic data types, currying, lambdas, the works. IMO, this is a much more powerful paradigm than object-orientation.

I would like to see these languages enter the "agile progamming" debate. But perhaps I am entirely missing the point? --DavidFrech
