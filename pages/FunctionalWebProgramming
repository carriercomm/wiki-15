Initial thoughts:

* an interpreter written in C - portable, easy to compile

* an implementation using David Turner's combinators - simple and intriguing

* a language much like Haskell, but perhaps simpler, and perhaps extended with features useful for web programming

* bootstrapped from another language, so we can "cheat" and ship much of the system in binary form (bytecodes).

* a built-in web server, but also the capability to use something like [[http://fastcgi.com/ FastCGI]], so it's usable with [[http://httpd.apache.org/ Apache]] and [[http://lighttpd.net/ lighttpd]].

----

>>>

Funny. Right after I wrote this the York Haskell Compiler project was announced on the Haskell mailing list. It fits three of these five, lacking only combinators (which everyone tells me to avoid) and the web-server.

>>

I don't know ''David Turner's combinators''. Can you point to some info on the web? Or explain what you mean?

>>>

The S, K, and I combinators, of Curry's [[http://en.wikipedia.org/wiki/Combinatory_logic combinatory logic]]. David Turner used combinators to implement the language Miranda, and published an article about it in the 80s - in ''Software - Practice & Experience'', I think.

>>

I think the older [[http://www.soi.city.ac.uk/~ross/Hope/ functional programming language Hope]] might be a nice starting point. --MichaelPruemm

>>>

There is a book on Hope at the PSU library. I'm not averse to it, but one thing I like about the more modern languages is that their syntax is quite nice, though in some ways Miranda's is nicer than Haskell's (esp w.r.t. boolean guards).