#!/usr/bin/perl -w

do "../common.pl";
do "../edit-common.pl";

sub run_svn {
    my @svn = ("$svn", @_);
    if ($use_subversion) {
        system(@svn) == 0 or die "can't run @svn: $!";
    }
}

sub write_file {
    my ($filename, $contents) = @_;

#    print STDERR "writing file $filename = $contents\n";
    open F, "> $filename" or choke("open $filename (for writing) failed: $!");
    print F $contents;
    close F;
}

sub make_backup_page {
    my ($page, $modstring) = @_;
    my $file = "$pagedir/$page";
    if (-r "$file" && -f "$file") {
        my $backup_file = "$archivedir/$page." . $modstring;
        write_file($backup_file, page_text($page));
    }
}

sub do_save {
    my $edit = $form{'edittext'};
    $edit =~ s/\r//g;   # CRLF -> LF

    my $mod_current = page_modtime("$page");

    # we have to check for edit collisions
    if ($mod_current != $form{'modtime'}) {
        $content = <<"";
<p>
Unfortunately, someone else has edited and saved $page since you started
editing it. The edit area still contains <strong>your</strong> version; if
you open an edit window on the current version of the page, you'll be able
to merge your changes.
</p>

        make_edit_page($edit);
        return "collided";      # we failed to save, so don't do a "show"
    }

    # check if user wants to delete the page - edittext has to consist
    # solely of the words "chainsaw kitty"
    if ($form{'edittext'} =~ m/^chainsaw kitty$/i) {
        run_svn("rm", "-q", "$pagedir/$page");
        run_svn("ci", "-q", "-m", "wiki: deleted $page", "$pagedir/");
        $page = $defaultpage;        # gotta go somewhere!
        return "ok";
    }
        
#    make_backup_page("$page", iso_timestamp("$mod_current"));

    # convert time stamps - now honors <pre>
    my $stamp = stamp(time());

    # XXX: change this when splitting method changes in rendering code
    # we're going to do "paragraph" markup delimited with multiple newlines
    # leave pre alone
    # This bit of code has the added affect of canonicalizing the edited text:
    # chunks (paras) are separated by exactly two \n's, and the whole thing,
    # when written out to disk, is followed by a single \n.

    my @paras =  split /\n{2,}/, $edit;
    foreach my $para (@paras) {
        $para =~ s/\[now\]/$stamp/ge unless $para =~ m/^\s+/;
    }

    # if this is a new page, do an "svn add"; but not until the page exists!
    my $svnadd = (-f "$pagedir/$page") ? 0 : -1;

    # capture current (file write) time so "svn ps modtime" is accurate
    my $new_modtime = time();

    # joins bits together separated by \n\n
    write_file("$pagedir/$page", (join "\n\n", @paras));

    # now we can do the actual svn add
    if ($svnadd) {
        run_svn("add", "-q", "$pagedir/$page");
    }

# XXX: remove 2nd \n after I fix ul code!!
# XXX: and add back in the '* ' at the start of the line!!
#    my $text = "* $page (modified $stamp from $ip)\n\n";

    # moved this out here so svn ci can use it too.
    my $ip = $ENV{'REMOTE_ADDR'};
    my $changed = "$page ... $stamp ... $ip";

    # prefix existing contents of RecentChanges with newest entry.
    my $contents = $changed . "\n\n" . page_text("RecentChanges");
    write_file("$pagedir/RecentChanges", $contents);

    # update modtime property
    run_svn("ps", "-q", "modtime", "$new_modtime", "$pagedir/$page");

    # update editcomment property
    run_svn("ps", "-q", "editcomment", "$form{'comment'}", "$pagedir/$page");

    # check in change to svn repo
    run_svn("ci", "-q", "-m", "wiki: $changed\ncomment: $form{'comment'}", "$pagedir/");

    return "ok";
}

# logic
# GET save/<page>  redirect to show/<page>
# POST save/<page>
#    if Submit pushed, then
#        try to save; if successful, redirect to show/<page>;
#                     otherwise, collision, so stay at save/<page> and re-edit.
#    else Cancel must have been pushed, so
#        redirect to show/<page>
#
sub do_request {
    my $method = $ENV{'REQUEST_METHOD'};
    if ($method =~ m/post/i){ 
        read(STDIN, my $form, $ENV{'CONTENT_LENGTH'});
        %form = parse_http_data($form);

        $form{'submit'} =~ m/save/i
            && (do_save() eq "collided") && return;   # skip redirection
    }
    redirect("post");
}

do_request()
