#!/usr/bin/perl -w

# $Id$

#use strict;

package nimblewiki;

# %q = ();

$| = 1;         # flush after each print

#$wikiword = "[A-Z][a-z0-9]+";
$wikiword0 = "[A-Z][a-z]+";
$wikiword  = "(?:$wikiword0)|(?:[0-9]+)";
$wikilink = "(?:$wikiword0)(?:$wikiword)+";
$interprefix = "[A-Z][A-Za-z0-9]+";
$interword = "[A-Za-z0-9]+";
$interquery = "$interword(?:[_+#?:.-]$interword)*";
#$markurl = "\001";

### Read in configuration variables ###
do "config.pl";

sub unescape_uri {
    $_ = shift;
    return undef unless defined;
    tr/+/ /;
    s/%([0-9a-fA-F]{2})/pack("C",hex($1))/ge;
    return $_;
}

sub escape_uri {
    my ($uri) = @_;

    # escape a minimal set - probably more chars are needed here
    $uri =~ s/([&=+?'"\000-\037\177])/"%" . unpack("H2", $1)/ge;
    $uri =~ tr/ /+/;    # may have to be %20
    $uri;
}

sub escape_html {
    s/&/&amp;/g;
    s/</&lt;/g;
#    s/>/&gt;/g;
}

sub parse_http_data {
    my @pairs;
    foreach (split( /&/, shift)) {
        my ($key, $value) = split(/=/, $_, 2);
        push @pairs, unescape_uri($key), unescape_uri($value);
    }
    @pairs;
}

sub choke {
    my ($errortext) = @_;
    my $subject = escape_uri($errortext);
    print <<EOT;
Content-type: text/html

<html>
  <head>
    <title>$wikiname :: An error occurred</title>
  </head>
  <body>
    <h1>Something went terribly wrong</h1>
    <p>An error occurred processing your last request.</p>
    <p>The error message was <em>$errortext</em>.</p>
    <p>Please <a href="mailto:$webhamster?subject=$subject">contact</a> the
       ding-dong responsible for this site with details about what you
       were doing when this happened.</p>
    <p>Thank you.</p>
  </body>
</html>
EOT
    exit;
}

sub read_file {
    my ($filename) = @_;
    my $contents = "";

    open F, "< $filename" or choke "open $filename (for reading) failed: $!";
    local $/;  # slurp mode
    $contents = <F>;
    close F;
#    print STDERR "reading file $filename = $contents\n";
    $contents;
}

sub write_file {
    my ($filename, $contents) = @_;

#    print STDERR "writing file $filename = $contents\n";
    open F, "> $filename" or choke "open $filename (for writing) failed: $!";
    print F $contents;
    close F;
}

sub append_file {
    my ($filename, $contents) = @_;

    open F, ">> $filename" or choke "open $filename (for appending) failed: $!";
    print F $contents;
    close F;
}

sub init_interwiki {
    my $file = "intermap";
    %intermap = (-r "$file" && -f "$file") ? split /\s+/, read_file($file) : ();
}

sub dispatch_on_action {
    %dispatch = (
        show   => \&do_show,
        edit   => $editable ? \&do_edit : \&do_show,
        search => \&do_text_search,
        name   => \&do_name_search,
        diff   => \&do_diff
    );

    if (exists $dispatch{$action}) {
        &{$dispatch{$action}}();
    } else {
        do_show();
    }
}

sub do_init {
    $script = (split '/', $ENV{'SCRIPT_NAME'})[-1];     # keep only last part

    $editable = $script eq $editscript;

    $method = $ENV{'REQUEST_METHOD'};
    if ($method =~ m/post/i){ 
        read(STDIN, my $form, $ENV{'CONTENT_LENGTH'});
        %form = parse_http_data($form);
    }

    # normal form of wiki URI is script?action=page
    ($action, $page, %query) = parse_http_data($ENV{'QUERY_STRING'});
    $action ||= "show";         # <nothing> -> ?show
                                # ?=page    -> ?show=page
    $page ||= $defaultpage;     # ?show     -> ?show=DefaultPage

    my $action_href = script_href("", "");

    $textsearchform = <<"";
<form action="$action_href" method="get" enctype="application/x-www-form-urlencoded">
  <p><input type="text" name="search" size="30" /></p>
</form>

    $namesearchform = <<"";
<form action="$action_href" method="get" enctype="application/x-www-form-urlencoded">
  <p><input type="text" name="name" size="30" /></p>
</form>

    init_interwiki();
    $content = "";
    $http_status = "200 Groovy";        # default is everything Ok
    @footerlines = ();
}

sub script_href {
    my ($action, $page) = @_;
    my $href = "";
    $href = "?$action=$page" if $action;  # and nothing otherwise!
    "${script}${href}";
}

sub scriptlink {
    my ($action, $page, $linktext) = @_;
    my $href = script_href($action, $page);
    "<a href=\"$href\">$linktext</a>";
}

sub scriptlinkclass {
    my ($action, $page, $linktext, $class) = @_;
    my $href = script_href($action, $page);
    "<a class=\"$class\" href=\"$href\">$linktext</a>";
}

sub do_request {
    do_init();
#    print_debug_values();

    # $action will match show" ...
    $method =~ m/post/i
        # both Save & Tweak buttons save the edit
        && $form{'submit'} =~ m/(save|tweak)/i
        && do_save() != 0
        && return;

    # dispatch unless we saved and save failed
    dispatch_on_action();            # ... does this as well on save
}

sub fancy_title {
    my ($title) = @_;

    if ($title =~ m/$wikilink/) {
        # run numbers into prev word
        $title =~ s/([a-z0-9])([A-Z])/$1 $2/g;
# these two make numbers separate
#        $title =~ s/([a-z])([A-Z0-9])/$1 $2/g;
#        $title =~ s/([0-9])([A-Z])/$1 $2/g;
    }
    else {
        $title =~ tr/_/ /;
        $title =~ s/^([a-z])/uc($1)/e;  # capitalize first letter
    }
    $title
}

sub fancy_link {
    my ($link) = @_;

    $link =~ tr/_/ /;   # works for both wiki and extended links
    $link;
}

sub generate_xhtml {
    my ($title, $heading, $robots) = @_;
    my $home_link = scriptlink("show", $defaultpage,
          "<img id=\"icon\" src=\"$iconimgsrc\" alt=\"$iconimgalt\" />");

    # Mostly we want the title and heading to be the same text. $heading is
    # usually a link to a search page, but the link text is the same as
    # $title. To get this behavior, pass "" for $heading. Sometimes,
    # though, they need to be different: if, for instance, we want inline
    # markup in the heading but not in the title (where it violates the
    # html spec). Or if we _don't_ want $heading to be a link (like on edit
    # pages).
    #
    # There is another wrinkle to this. We don't want web spiders to follow
    # links to edit or search pages and follow the links because they might
    # get stuck in circles or do damage to the wiki. Only "normal"
    # (do_show) pages should be indexed.

    $heading = scriptlink("search", $page, "$title") unless $heading;
    $heading_template =~ s/<home \/>/$home_link/;
    $heading_template =~ s/<heading \/>/$heading/;

    $metas{'robots'} = "${robots}index,${robots}follow";

    my $meta_elements = join "\n",
        map "<meta name=\"$_\" content=\"$metas{$_}\" />", keys %metas;

    # string together footer lines, separated by <br />
    my $footer = join "<br />\n", @footerlines;
    
    print <<EOT;
Content-type: text/html
Status: $http_status

<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
          PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
$meta_elements
<link rel="stylesheet" href="$style" type="text/css" />
<title>$wikiname :: $title</title>
</head>
<body>

<div id="header">
$heading_template
</div>

<div id="content">
$content
</div>

<div id="footer">
<hr />

$footer
</div>

</body>
</html>
EOT
}

# This bit of code is ugly because it is being passed an array of references
# to scalars that are to be modified. Hence the $$n everywhere.
sub leading_zero {
    my @nums = @_;
    foreach my $n (@nums) {
        $$n = "0$$n" if ($$n < 10);
    }
}

sub pretty_time {
    my ($time) = @_;
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = localtime($time);
    $year += 1900;
    my $month = (qw(January February March April May June July
                    August September October November December))[$mon];
    $mon = $mon + 1;    # was indexed from 0
    leading_zero \($mon, $mday, $hour, $min, $sec);
    ($year, $mon, $month, $mday, $hour, $min, $sec);
}

sub stamp {
    my ($time) = @_;
    my ($year, $mon, $month, $mday, $hour, $min, $sec) = pretty_time($time);
    "$year $month $mday $hour:$min";
}

sub iso_timestamp {
    my ($time) = @_;
    my ($year, $mon, $month, $mday, $hour, $min, $sec) = pretty_time($time);
    "$year-$mon-$mday" . "T" . "$hour:$min:$sec";
}

# If the file doesn't exist or isn't readable, use a modtime of 0.
# We're long past 1970, so this should be ok. ;-)
# Get time by reading the svn property "modtime" on the file.
sub page_modtime {
    my ($p) = @_;
    my $pp = "$pagedir/$p";
    (-r "$pp" && -f "$pp")
        ? `svn pg modtime $pp`
        : 0;
}

sub modtimestring {
    my ($p) = @_;
    stamp(page_modtime("$p"));
}

sub editfooter {
    my $edittext = scriptlink("edit", $page, "EditText") . " of this page";
    my $modtime = page_modtime("$page");
    my $modtext  = ($modtime != 0)
        ? " (last edited " .  scriptlink("diff", $page, stamp($modtime)) . ")"
        : "";

    push @footerlines, "$edittext$modtext\n";
}

sub findfooter {
    push @footerlines, scriptlink("show", "SearchWiki", "SearchWiki")
        . " for titles or text,\n"
        . "browse " . scriptlink("show", "RecentChanges", "RecentChanges") . ",\n"
        . "or return to " . scriptlink("show", $defaultpage, $defaultpage) . "\n";
#Search for &nbsp;$searchform
#Pages like &nbsp;$namesearchform

}

#  <img src="images/valid-xhtml10" alt="Valid XHTML 1.0 Strict!" />
#  <img src="images/valid-css" alt="Valid CSS!" />

sub validator {
    push @footerlines, << "";
<p>
  <a href="http://validator.w3.org/check/referer">
    <img src="images/valid-xhtml10" alt="Valid XHTML 1.0 Strict!" />
  </a>
  <a href="http://jigsaw.w3.org/css-validator/check/referer">
    <img src="images/valid-css" alt="Valid CSS!" />
  </a>
  <a href="http://www.spreadfirefox.com/?q=affiliates&amp;id=0&amp;t=62">
    <img src="http://sfx-images.mozilla.org/affiliates/Buttons/110x32/take.gif"
         alt="Get Firefox!" title="Get Firefox!" />
  </a>
</p>

}

sub make_wiki_link {
    my ($page) = @_;
    my $link = fancy_link($page);
    (-r "$pagedir/$page" && -f "$pagedir/$page")
        ? scriptlink("show", $page, $link)
        : ($editable ? scriptlinkclass("edit", $page, $link, "missing")
           : "$page");
}

# a way to escape query strings? Thinking of google queries w/embedded spaces.
sub make_interwiki_link {
    my ($prefix, $suffix, $link_text) = @_;
    my $interlink = $intermap{$prefix};

    $link_text =~ tr/_/ /;
#    $link_text =~ s/#/ :: /g;

    defined $interlink
        ? "<a href=\"$interlink$suffix\">$link_text</a>" : "$link_text";
}

sub hide {
    my ($link) = @_;

    # use "" to hide links
    $link =~ s/($wikiword)/$1\"\"/go;
#   $link =~ s/($extendedlinkbit)/$1\"\"/go;
    $link;
}

sub convert_wiki_links {
    s/($wikilink)/make_wiki_link($1)/geo;
#    s/($extendedlinkre)/make_wiki_link($1)/geo;

    # forced link of single word
#    s/``($extendedlinkbit)/make_wiki_link($1)/geo;
}

sub convert_interwiki_links {
    s/($interprefix):($interquery)/hide(make_interwiki_link($1, $2, "$1:$2"))/geo;
}

@nestelems = ();
$nestdepth = 0;

sub pushelem {
    my ($type) = @_;
    my $out = indent() . "<$type>";
    push @nestelems, $type;
    $nestdepth++;
    $out;
}

sub popelem {
    $nestdepth--;
    indent() . "</" . (pop @nestelems) . ">\n";
}

sub unwind {
    my $out = "";
    $out .= popelem() while ($nestdepth);
    $out;
}

sub indent {
    ' ' x ($nestdepth * 2);
}

# I just learned that nested ol and ul elements have to be _inside_ an li.
# ol and ul can only contain li - nothing else. So we need to rewrite this
# code to keep li's "open" until the last possible moment. Make them part of
# of the pushelem/popelem code. Misuse of nesting (by wiki content authors)
# may result in li's with no text content.

# a couple of thoughts. use split //, type to blow up type/nesting into an
# array/list of chars. Iterate over this to do indenting.

sub oldlistitem {
    my ($type, $text) = @_;
    my $out = "";
    my $elem = $type =~ m/\*/ ? "ul" : "ol";
    my $depth = 2 * (length $type) - 1;

    if ($nestdepth == 0)
    { $out .= pushelem($elem) . "\n"; }
    else
        # close last open li
    { $out .= popelem(); }

    $out .= pushelem("li") . "\n" . pushelem($elem) . "\n"
        while ($depth > $nestdepth);

    $out .= popelem()
        while ($depth < $nestdepth);

    # now we're at the right level but might be inside a different list elem
    $out .= popelem() . pushelem("li") . "\n" . pushelem($elem) . "\n"
        if ($nestelems[-1] ne $elem);

    # now indent and add open li and text
    $out . pushelem("li") . $text . "\n";

    $out .= pushelem($elem) . "\n" . pushelem("li") while ($depth > $nestdepth);
    $out .= popelem()                               while ($depth < $nestdepth);

    # now we're at the right level but might be inside a different nest elem
    $out .= popelem() . pushelem("li") . pushelem($elem)
        if (@nestelems && $nestelems[-1] ne $elem);

    # now indent for item
    $out . indent() . "<li>$text</li>";
}

sub listblock {
    my ($listpara) = @_;
    my $elem = $listpara =~ m/\*/ ? "ul" : "ol";

    $listpara =~ s:^([*#]{1,5})\s*(.*):<li>$2</li>\n:gm;

    wrap("$elem", "\n$listpara");
}

sub wrap {
    my ($elem, $contents) = @_;
    "<$elem>$contents</$elem>";
}

# For every voice except the first (">") there is an open div.
$current_voice = 1;

sub end_voice {
    ($current_voice != 1) ? "</div>\n" : "";
}

sub start_voice {
    my ($v) = @_;
    if ($v != $current_voice) {
        my $old = end_voice();
        my $new = ($v != 1) ? "<div class=\"voice" . $v . "\">" : "";
        $current_voice = $v;
        "$old$new";
    }
    else { "" }
}

$curlist = "";

sub listitem {
    my ($kind, $item, $class) = @_;
    my $result = "";
    
    unless ($curlist) {
        $kind = $kind eq '#' ? 'ol' : 'ul';
        $curlist = "</$kind>\n";
        $result .= "<$kind>\n";
    }
    $result . "<li$class>$item</li>";
}

sub listend {
    if ($curlist) {
        my $result = $curlist;
        $curlist = "";
        $result;
    }
    else { "" }
}

# Support for flickr badges.

# The flickr script generate images each inside a div with class
# "flickr_badge_image".
#
# Notes on usage of Flickr badge query API:
#   size=s gives small square pix;
#   size=t gives small thumbnails;
#   size=m gives rather large pix (4 across)
#   display=random
#   display=latest
#   layout=h  (tables - ugh!)
#   layout=v  (ditto!)
#   layout=x  (wraps each pic in a div)
#   source=all
#   source=user
#     user=<id>
#   source=user_tag
#     user=<id>
#     tag=<tag>
#   source=all_tag
#     tag=<tag>

sub flickr_badge {
    my ($count, $whose, $which, $tags) = @_;

    $count = 5 if not $count;
    $which = "random" if not $which;

    # init hash for query string
    my %q = (
             count => $count,
             size  => 't',          # 's' for small squares; 'm' for biggies
             display => $which,
             layout => 'x'          # this gives us div's rather than td's
             );

    if ($whose eq '') {
        $whose = 'user';
        $q{'user'} = "$flickr_user";
    }

    # Separate tags into an array...
    my @tags = split / +/, $tags;

    # ...then escape the rest for query string
    foreach my $t (@tags) {
        $t = escape_uri($t);
    }

    if (@tags) {
        $q{'tag'} = join '+', @tags;
        $whose .= '_tag';
    }

    $q{'source'} = $whose;

    my @pairs = ();
    while (my ($k, $v) = each %q) {
        push @pairs, "$k=$v";
    }

    # Finally!
    my $query = join "&amp;", @pairs;

    return <<"";
<div class="flickr_badge">
  <script type="text/javascript" src="http://www.flickr.com/badge_code_v2.gne?$query">
  </script>
</div>

}

sub block_markup {
    my $class = "";
    $class = " class=\"changed\"" if s#^\a##;
    
    if (m/^([*#])\s*(.*)/) {
        $_ = listitem($1, $2, $class);
    } else {
        s#^(\s+.*)#<pre$class>\n$1\n</pre>#s ||
        s#^"{2}(.*)#<blockquote$class><p>$1</p></blockquote>#s ||

        # hrules and headings return to voice 1
        s#^-{4,}#start_voice(1) . "<hr />"#e ||
        s/^(={1,4})\s*(.*)/start_voice(1) . wrap("h".((length $1)+1), $2)/e ||

        # special "forth" voice
        s/^(>>forth)/start_voice("forth")/e ||
        
        # multiple "voices"
        s/^(>{1,8})/start_voice(length($1))/e ||
#        s/^([*#]{1,5})\s*(.*?)/listitem($1, $2)/gme ||
#        s/^([*#]{1,5}.*?)/listblock($1)/e ||

        # special links - these generate form elements, which are considered to
        # be block-level markup. In order to validate, these cannot be enclosed
        # in p elems.
        s/^\[namesearch\]/$namesearchform/ ||
        s/^\[textsearch\]/$textsearchform/ ||

        # comments, using Haskell notation: --
        s/^--.*//s ||
        # ...could also render this, and put display: none in the css...
#        s#^--\s*(.*)#<p class="comment">$1</p>#s ||

        # generate a flickr badge, with user or public content
        s/^\[flickr(([0-9]+))?(:(all))?(:(latest))?(\s+(.*))?\]/flickr_badge($2, $4, $6, $8)/e ||

        # nothing else matches, make it a p
        s#^(.*)#<p$class>$1</p>#s;
        $_ = listend() . $_;
    }
}

sub hideuri {
    $uri[$uri++] = shift;
    "$urimark$uri$urimark";
}

sub hide_uris {
#    s/\[\[.+\]\]/hideuri($1)/ge;
}

sub show_uris {
    # remove double quotes everywhere except at the start of a line (where
    # it denotes a blockquote) - can be used to foil wikilinks, and to add
    # plurals to singularly-linked pages
    s/(.)""/$1/g;
}

sub obfuscate_mailto {
    my ($email, $link) = @_;
    $email =~ s/(.)/"%" . unpack("H2", $1)/ge;
    "<a href=\"mailto:$email?subject=$page\">$link</a>";
}

sub inline_markup {
    hide_uris();

    s#'{3}(.+?)'{3}#<strong>$1</strong>#gs;
    s#'{2}(.+?)'{2}#<em>$1</em>#gs;
    # XXX: code, cite, kbd, ???

    # forth word
    s#fw\(\((.+?)\)\)#<code class="forth">$1</code>#gs;

    # Quote character entities so that the browser doesn't "helpfully"
    # convert them. Use !!name!! or ??name??.
    s#[!\?]{2}(.+?)[!\?]{2}#&$1;#gs;

    # obfuscated mailto links: [[mailto:email link text]]
    # link text is required, since what would we put there other than the
    # unescaped mailto address, thereby making the whole thing moot?
    s#\[\[mailto:(\S+)\s+(.+)\]\]#hide(obfuscate_mailto($1, $2))#ge;

    # named interwiki link: [[prefix:suffix link text]]
    s/\[\[($interprefix):($interquery)\s+(.+?)\]\]/hide(make_interwiki_link($1, $2, $3))/geo;

    # inline img link: [[uri.ext alt text]] where ext is img type
    s#\[\[img (\S+\.(?:jpg|jpeg|gif|png))\s+(.+?)\]\]#hide(
        "<img src=\"$1\" alt=\"$2\" />")#ge;

    # unnamed href link: [[uri]]
    s#\[\[(\S+?)\]\]#hide("<a href=\"$1\">$1</a>")#ge;

    # generic href link: [[url lots of link text]]
    s#\[\[(\S+?)\s+(.+?)\]\]#hide("<a href=\"$1\">$2</a>")#ge;

    # ISBN ...
    # RFC ...

    convert_interwiki_links();
    convert_wiki_links();

    show_uris();
}

sub page_text {
    my ($page) = @_;
    my $file  = "$pagedir/$page";
    (-r "$file" && -f "$file") ? read_file($file) : "";
}

sub render_body {
    escape_html();

    # XXX if we do inline on a per-para basis, we can "catch" dangling
    # markup that spans para boundaries. I wonder if everything shouldn't
    # be wrapped in the foreach by para.
#    inline_markup();

    # we're going to do "paragraph" markup delimited with multiple newlines
    foreach (split /\n{2,}/, $_) {
        inline_markup() unless m/^\a?\s+/;  # leave pre alone
        block_markup();
        $content .= "$_\n" , unwind();
    }

    # close any open list
    $content .= listend();
    
    # close our last "voice" div
    $content .= start_voice(1);
}

sub render_page {
    my ($robots) = @_;
    render_body();
    editfooter() if $editable;
    findfooter();
    validator();
    generate_xhtml(fancy_title($page), "", $robots);
}

# do_xxx needs to do something like this:
# $content = ...
# @footerlines  = ...
# generate_xhtml($title, $page_heading);
sub do_show {
    my $robots = "";
    $_ = page_text($page);

    # if not editable and non-existent, return a 404 Not found error page.
    # This is mostly so spiders know that the page really doesn't exist.
    unless ($_) {
        if ($editable) {
            $_ = "$page doesn't exist. Why not create it by editing the text of this page?\n";
        } else {
            $_ = "Sorry, that page doesn't exist.\n";
            $http_status = "404 Not found";
        }
        $robots = "no";
    }

    render_page($robots);
}

sub make_edit_page {
    my ($text) = @_;
    my $mod = page_modtime("$page");
    my $action_href = script_href("show", $page);

    $content .= <<"" unless $text;
  <p>
    $page doesn't exist. Why not create it by entering some text below?
  </p>

    $content .= <<"";
<form action="$action_href" method="post" enctype="application/x-www-form-urlencoded">
  <p>
    <textarea name="edittext" rows="25" cols="75">$text</textarea>
  </p>
  <p>
    What did you change? Your comments will be added to Subversion:<br />
    <input type="text" name="comment" value="" size="75" />
  </p>
  <p>
    If you've made only small changes - like to punctuation or spelling -
    and don't want a new entry in RecentChanges - press Tweak.
    Otherwise, to save changes and log RecentChanges, press Save.
  </p>
  <p>
    <input type="submit" name="submit"  value="Tweak" />
    <input type="submit" name="submit"  value="Save" />
    <input type="reset"                 value="Revert" />
    <input type="submit" name="submit"  value="Cancel" />
    <input type="hidden" name="modtime" value="$mod" />
  </p>
</form>

    validator();
    my $edit_title = "Editing " . fancy_title($page);

    # prevent making title a link, no robots
    generate_xhtml($edit_title, $edit_title, "no");
}

sub do_edit {
    make_edit_page(page_text($page));
}

sub make_backup_page {
    my ($page, $modstring) = @_;
    my $file = "$pagedir/$page";
    if (-r "$file" && -f "$file") {
        my $backup_file = "$archivedir/$page." . $modstring;
        write_file($backup_file, page_text($page));
    }
}

sub svn_command {
    my @svn = ("svn", @_);
    if ($subversion eq "yes") {
        system(@svn) == 0 or die "can't run @svn: $!";
    }
}

sub do_save {
    my $edit = $form{'edittext'};
    $edit =~ s/\r//g;   # CRLF -> LF

    my $mod_current = page_modtime("$page");

    # we have to check for edit collisions
    if ($mod_current != $form{'modtime'}) {
        $content = <<"";
<p>
Unfortunately, someone else has edited and saved $page since you started
editing it. The edit area still contains <strong>your</strong> version; if
you open an edit window on the current version of the page, you'll be able
to merge your changes.
</p>

        make_edit_page($edit);
        return -1;      # we failed to save, so don't do a "show"
    }

    # check if user wants to delete the page
    if ($form{'edittext'} =~ m/chainsaw kitty/i) {
        svn_command("rm", "-q", "$pagedir/$page");
        svn_command("ci", "-q", "-m", "wiki: deleted $page", "$pagedir/");
        $page = $defaultpage;        # gotta go somewhere!
        return 0;
    }
        
    make_backup_page("$page", iso_timestamp("$mod_current"));

    # convert time stamps - now honors <pre>
    my $stamp = stamp(time());

    # XXX: change this when splitting method changes in rendering code
    # we're going to do "paragraph" markup delimited with multiple newlines
    # leave pre alone
    # This bit of code has the added affect of canonicalizing the edited text:
    # chunks (paras) are separated by exactly two \n's, and the whole thing,
    # when written out to disk, is followed by a single \n.

    my @paras =  split /\n{2,}/, $edit;
    foreach my $para (@paras) {
        $para =~ s/\[now\]/$stamp/ge unless $para =~ m/^\s+/;
    }

    # if this is a new page, do an "svn add"; but not until the page exists!
    my $svnadd = (-f "$pagedir/$page") ? 0 : -1;

    # capture current (file write) time so "svn ps modtime" is accurate
    my $new_modtime = time();

    # joins bits together separated by \n\n
    write_file("$pagedir/$page", (join "\n\n", @paras));

    # now we can do the actual svn add
    if ($svnadd) {
        svn_command("add", "-q", "$pagedir/$page");
    }

# XXX: remove 2nd \n after I fix ul code!!
# XXX: and add back in the '* ' at the start of the line!!
#    my $text = "* $page (modified $stamp from $ip)\n\n";

    # moved this out here so svn ci can use it too.
    my $ip = $ENV{'REMOTE_ADDR'};
    my $changed = "$page ... $stamp ... $ip";

    # tweak will save edit but not affect RecentChanges
    if ($form{'submit'} =~ m/save/i) {
        # prefix existing contents of RecentChanges with newest entry.
        my $contents = $changed . "\n\n" . page_text("RecentChanges");
        write_file("$pagedir/RecentChanges", $contents);
    }

    # update modtime property
    svn_command("ps", "-q", "modtime", "$new_modtime", "$pagedir/$page");

    # update editcomment property
    svn_command("ps", "-q", "editcomment", "$form{'comment'}", "$pagedir/$page");

    # check in change to svn repo
    svn_command("ci", "-q", "-m", "wiki: $changed\ncomment: $form{'comment'}", "$pagedir/");

    return 0;
}

sub filter_pages {
    my ($dir, $pred) = @_;
    opendir PAGES, "$dir" or die "can't opendir $dir: $!";
    my @matches = grep { ! m/^\./ && -r "$dir/$_" && -f "$dir/$_"
                         && &$pred() } readdir PAGES;
    closedir PAGES;
    return @matches;
}

sub do_text_search {
    my @matches = filter_pages($pagedir, sub { page_text($_) =~ m/$page/i });
    gen_search_page("Pages matching $page",
                    "Pages matching <em>$page</em>", @matches);
}

sub do_name_search {
    my @matches = filter_pages($pagedir, sub { m/$page/i });
    gen_search_page("Page names matching $page",
                    "Page names matching <em>$page</em>", @matches);
}

sub gen_search_page {
    my ($title, $heading, @matches) = @_;
    my $text = "";
    foreach (sort @matches) {
        $text .= "<li>" . make_wiki_link($_, $_) . "</li>\n";
    }
    $content  = "<ul>\n$text</ul>\n" if $text;
    findfooter();
    validator();
    generate_xhtml($title, $heading, "no");
}

sub do_diff {
    # get a time stamp for the earlier version of the page
    my $when = "$page.";
    $_ = $query{when};
    if (m/\d\d\d\d-\d\d-\d\d(T\d\d:\d\d(:\d\d)?)?/) {
        # some form of ISO time
        $when .= $_;
        $when .= "T00:00" if $1 eq "";
        $when .= ":00" if $2 eq "";
    }
    else {  # should be a delta in hours
        my $delta = 24;     # default, in hours
        $delta = $1 if m/(\d+)h?/i;
        $when .= iso_timestamp(time() - $delta * 60 * 60);
    }

    # find earlier version of page
    my @matches = filter_pages($archivedir, sub { m/^$page/ });
    my $oldpage = "/dev/null";
    foreach (sort @matches) {
        last if $_ gt $when;
        $oldpage = "$archivedir/$_";
    }

    my $cmd = "diff -U 99999 $oldpage $pagedir/$page";
    my $contents = "";
    open DIFF, "-|", $cmd or choke "cannot compare $page with $oldpage: $!";

    # ignore first few lines until line starts with @@
    while (<DIFF>) {
        last if /^@@/;
    }

    my @contents = "";
    my @saved = ();
    my $isnew = 0;

    while (<DIFF>) {
        next if /^-/;   # don't care about deleted lines
        $isnew = 1 if /^[+]\s*\S/;
        s/^.//;

        if (/^$/) {     # blank line
            #@saved = map { s/^./+/; $_ } @saved if $isnew;
            $contents .= ($isnew ? "\a" : "");
            $contents .= join '', @saved;
            $contents .= "\n";
            $isnew = 0;
            @saved = ();
        } else {
            push @saved, $_;
        }
    }   
    if (@saved) {
        $contents .= ($isnew ? "\a" : "");
        $contents .= join '', @saved;
    }
    close DIFF;

    $_ = $contents;
    render_page("no");
}

sub do_choke {
    $_ = read_file("xyzzy");
}

sub print_debug_values {
    print STDERR "\n\n======================== new CGI call =========================\n";
    print STDERR ":: ENV ::\n";
    foreach (sort keys %ENV) {
        print STDERR "$_ = $ENV{$_}\n";
    }
    print STDERR "\n:: Query ::\n";
    foreach (sort keys %query) {
        print STDERR "$_ = $query{$_}\n";
    }
    print STDERR "\n:: Form ::\n";
    foreach (sort keys %form) {
        print STDERR "$_ = $form{$_}\n";
    }
    print STDERR "\n:: Intermap ::\n";
    foreach (sort keys %intermap) {
        print STDERR "$_ = $intermap{$_}\n";
    }
    print STDERR "\n:: VARIABLES ::\n";
    print STDERR "script = $script\n";
#    print STDERR "base = $base\n";
    print STDERR "page = $page\n";
    print STDERR "action = $action\n";
}

do_request();
#do_choke();
